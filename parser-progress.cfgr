module grammar;
# main part
program : {unit_dcl | conversion_dcl} function_def {function_def};          #done
function_def : type identifier arg_list block_stmt;

arg_list : "(" [type identifier {"," type identifier}] ")" ;                #done

block_stmt : "{" {stmt} "}";                                                #done
stmt: block_stmt | return_stmt | loop_stmt | call_stmt | if_stmt | print_stmt
| explain_stmt  | assign_stmt
| var_dcl_stmt | break_stmt | continue_stmt | type_check_stmt;          #done

# flow control statements
return_stmt : "return" expr ";";                        #done
loop_stmt : "while" "(" expr ")" stmt ;         #in progress, will work afer expr and statement
call_stmt: identifier "(" args ")" ";";
args: [expr {"," expr}];
if_stmt : "if" "(" expr ")" stmt ["else" stmt];
break_stmt : "break" ";";                       #done!
continue_stmt : "continue" ";";                 #done!

# bulit-in statements
print_stmt : "print" "(" args ")" ";";
explain_stmt : "explain" "(" unit_type ")";
type_check_stmt: "type" "(" identifier ")";
assign_stmt : identifier "=" expr ";";
var_dcl_stmt : type (identifier ";") | [assign_stmt] ;

# defining custom units
unit_dcl : "unit" identifier ["as" compound_expr ] ";";         # done
# conversion expression for compound unit definition
# only one division is possible
compound_expr: "<" compound_part ["/" compound_part] ">" ";";   # done
compound_part: compound_term {"*" compound_term};               # done
compound_term: unit_type ["^" non_zero_number];                 # done
unit_type: base_unit | identifier;                              # done

# defining unit relationships
conversion_dcl: "let" unit_type arg_list conv_fun;              #todo
# expressions limited to arithmetic operations
conv_fun : "{" conv_unit_expr "}" ";";
 conv_unit_expr: multi_unit_expr {add_op multi_unit_expr};      #done
multi_unit_expr: power_unit_expr {multi_op power_unit_expr};    #done
power_unit_expr: {unary_unit_expr "^"} unary_unit_expr;         #done
unary_unit_expr: ["-"] unit_expr;
unit_expr: "(" conv_unit_expr ")" | unit_value;
unit_value: number | base_unit | identifier;


# operator precedence
expr : unit_type "(" or_expr ")" | or_expr;                     #todo
or_expr : and_expr { "||" and_expr};
and_expr : comp_expr {"&&" comp_expr};
comp_expr : rel_expr {comp_op rel_expr};
rel_expr : arithmetic_expr {rel_op arithmetic_expr};
arithmetic_expr: multi_expr {add_op multi_expr};
multi_expr: power_expr {multi_op power_expr};
power_expr: {unary_expr "^"} unary_expr;
unary_expr: {unary_op} not_unary_expr;
not_unary_expr: "(" expr ")" | value;

# eliminate left recursion in power operators

# operators
comp_op: "==" | "!=";
rel_op: "<="|">="|"<"|">";
add_op: "+" | "-";
multi_op: "/" | "*" ;
unary_op: "!"|"-";

# values
value : call_stmt |  literal | identifier;
identifier : ((underscore  (letter | digit)) | letter) {letter | digit | underscore};
literal: base_type| string | number;
type: base_type | identifier;
base_type: "int" | "float" | "bool" | "string" | "compound" | base_unit;
base_unit: "kilogram" | "meter" | "second";
string: "\"" {character} "\"";
character: letter | digit |special_char;
letter: "a"-"z" | "A"-"Z";
special_char: underscore | "\\" escape_char | "." | "," | "(" | ")" | "{" | "}" | " " | ":" |"-";
escape_char: "t" | "n" | "\\";

number : integer ["." {"0"} non_zero_number];
integer : "0" | non_zero_number;
non_zero_number :  non_zero_digit {digit};
digit: "0" | non_zero_digit;
non_zero_digit: "1" - "9";
underscore: "_";