module grammar;
# main part
program : {unit_dcl | conversion_dcl} function_def {function_def}; #p
function_def : type identifier parameters block_stmt;              #p

parameters : "(" [type identifier {"," type identifier}] ")" ;     #p


block_stmt : "{" {stmt} "}";
stmt: block_stmt | return_stmt | while_stmt | call_stmt | if_else_stmt | print_stmt
| explain_stmt  | assign_stmt
| var_dcl_stmt | break_stmt | continue_stmt | type_check_stmt;

# flow control statements
return_stmt : "return" expr ";";                            #p
while_stmt : "while" "(" expr ")" stmt ;                    #p
call_stmt: call ";";                                        #p
args: [expr {"," expr}];                                    #p
if_else_stmt : "if" "(" expr ")" stmt ["else" stmt];        #p
break_stmt : "break" ";";                                   #p
continue_stmt : "continue" ";";                             #p

# bulit-in statements
print_stmt : "print" "(" args ")" ";";                      #p
explain_stmt : "explain" "(" unit_type ")";                 #p
type_check_stmt: "type" "(" identifier ")";                 #p

assign_stmt : identifier "=" expr ";";                      # todo need to be done together
var_dcl_stmt : type ( (identifier ";") | assign_stmt);      #

# defining custom units
unit_dcl : "unit" identifier ["as" compound_expr ] ";";         #p
# conversion expression for compound unit definition
# only one division is possible
compound_expr: "<" compound_part ["/" compound_part] ">" ";";   #p
compound_part: compound_term {"*" compound_term};               #p
compound_term: unit_type ["^" non_zero_number];                 #p

# defining unit relationships
conversion_dcl: "let" unit_type parameters "{" conv_unit_expr "}" ";";    #p
# expressions limited to arithmetic operations
 conv_unit_expr: multi_unit_expr {add_op multi_unit_expr};                  #p
multi_unit_expr: power_unit_expr {multi_op power_unit_expr};                   #p
power_unit_expr: {unary_unit_expr "^"} unary_unit_expr;     # need to reconsider that onep
unary_unit_expr: ["-"] unit_expr;                                       #p
unit_expr: "(" conv_unit_expr ")" | number | identifier;    #p



# operator precedence
or_expr : and_expr { "||" and_expr};                    #p
and_expr : comp_expr {"&&" comp_expr};                  #p
comp_expr : rel_expr {comp_op rel_expr};                #p
rel_expr : arithmetic_expr {rel_op arithmetic_expr};    #p
arithmetic_expr: multi_expr {add_op multi_expr};        #p
multi_expr: power_expr {multi_op power_expr};           #p
power_expr: {unary_expr "^"} unary_expr;                #p
unary_expr: [unary_op] not_unary_expr;                  #p
expr: "(" or_expr ")" | value;                          #p

# eliminate left recursion in power operators

# operators
comp_op: "==" | "!=";
rel_op: "<="|">="|"<"|">";
add_op: "+" | "-";
multi_op: "/" | "*" ;
unary_op: "!"|"-";

# values
value : call |  literal | identifier;               #p
call : unit_type "(" args ")";                      #p

unit_type: base_unit | identifier;
identifier : ((underscore  (letter | digit)) | letter) {letter | digit | underscore};

literal: base_type| string | number;
type: base_type | identifier;
base_type: "int" | "float" | "bool" | "string" | "compound" | base_unit;
base_unit: "kilogram" | "meter" | "second";
string: "\"" {character} "\"";
character: letter | digit |special_char;
letter: "a"-"z" | "A"-"Z";
special_char: underscore | "\\" escape_char | "." | "," | "(" | ")" | "{" | "}" | " " | ":" |"-";
escape_char: "t" | "n" | "\\";

number : integer ["." {"0"} non_zero_number];
integer : "0" | non_zero_number;
non_zero_number :  non_zero_digit {digit};
digit: "0" | non_zero_digit;
non_zero_digit: "1" - "9";
underscore: "_";